# 아이템 38 any 타입은 가능한 한 좁은 범위에서만 사용하기
- 타입 채킹이 가능한 부분도 영향을 주지 않도록 any는 불가피한 케이스 한 곳에서만 사용하자
- 특히 함수 반환이 any가 되지 않도록 주의하자
- \@ts-ignore를 any 대신 사용할 수 있다.

# 아이템 39 any를 구체적으로 변형해서 사용하기
- any를 응용한 any\[\] 등으로 구체화 가능하다면 구체화해야 하자

# 아이템 40 함수 안으로 타입 단언문 감추기
- 타입 단언을 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안에 단언하여 범위를 좁히고 오류를 예방하자.

# 아이템 41 any의 진화를 이해하기
- any 타입에 접근함에 따라 타입이 추론되어 구체적인 코드로 진화할 수 있다(타입 좁히기와 다름)
- 하지만 자동으로 진화하는 것보다 명시적인 구분을 추가해 주는 것이 좋다

# 아이템 42 모르는 타입의 값에는 any 대신 unknown 사용하기
- any는 어떤 타입이든 할당할 수 있고 어떤 타입으로도 할당될 수 있다.
- unknown은 어떤 타입이든 할당할 수 있으나 추론이 되기 시작하면 추론된 타입으로 사용된다.
- 타입을 특정할 수 없지만 타입 체킹이 되어야할 경우 unknown을 쓰자
- \{\}는 null과 undefined를 제외한 모든 값이다
- object는 원시타입을 제외한 모든값이다. 

# 아이템 43 몽키 패치보다는 안전한 타입을 사용하기
- 전역 변수나 DOM에 데이터를 저장하지 말자
- 불가피한 경우 내장 타입에 보강이나 사용자 정의 인터페이스로 단언하여 타입이 추론 가능하도록 하고 사용하자

# 아이템 44 타입 커버리지를 추적하여 타입 안정성 유지하기
- noImplicitAny가 설정되어 있어도 명시적 any 또는 서드파티 타입 선언으로 코드 내에 any가 존재할 수 있다.
- 작성한 프로그램의 타입이 얼마나 잘 선언되어 있는지 추적하여 관리해야 한다.